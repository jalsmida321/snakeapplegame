<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Orber - A Unique Number Path Puzzle Game | Connect Numbers in Sequence</title>
    <meta name="description" content="Play Orber, an innovative puzzle game that challenges you to connect numbers in sequence. With progressive difficulty levels, intuitive controls, and brain-teasing challenges, it's perfect for puzzle enthusiasts of all ages. Test your logical thinking and pathfinding skills in this unique gaming experience.">
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <link rel="apple-touch-icon" sizes="180x180" href="https://snakeapplega.me/src/icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="https://snakeapplega.me/src/icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://snakeapplega.me/src/icons/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="theme-color" content="#ffffff">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2200116120340744"
     crossorigin="anonymous"></script>
    <style>
    :root {
        --primary: #4a90e2;
        --primary-dark: #357abd;
        --success: #4CAF50;
        --error: #f44336;
        --background: #f0f4f8;
        --cell-bg: #ffffff;
    }

    body {
        font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
        min-height: 100vh;
        margin: 0;
        background: #f0f8ff;
        color: #2c3e50;
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
    }

    header {
        background-color: #4CAF50;
        color: white;
        text-align: center;
        padding: 1em;
        border-radius: 10px;
        margin-bottom: 20px;
    }

    nav {
        background-color: #333;
        padding: 1em;
        border-radius: 10px;
        margin-bottom: 20px;
    }

    nav a {
        color: white;
        text-decoration: none;
        padding: 0.5em 1em;
        margin: 0 0.5em;
    }

    nav a:hover {
        background-color: #555;
        border-radius: 5px;
    }

    .game-title {
        font-size: 48px;
        font-weight: 800;
        text-align: center;
        margin-bottom: 10px;
        background: linear-gradient(45deg, var(--primary), var(--primary-dark));
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        text-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .game-intro {
        color: #64748b;
        text-align: center;
        max-width: 600px;
        margin: 0 auto 40px;
        font-size: 16px;
        line-height: 1.6;
    }

    .game-container {
        background: rgba(255, 255, 255, 0.95);
        padding: 30px;
        border-radius: 24px;
        box-shadow: 
            0 10px 20px rgba(0,0,0,0.1),
            0 6px 6px rgba(0,0,0,0.05),
            0 0 100px rgba(74,144,226,0.1);
        margin-bottom: 30px;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255,255,255,0.2);
        position: relative;
        max-width: fit-content;
        margin: 0 auto 30px;
    }

    .game-grid {
        display: grid;
        gap: 12px;
        padding: 10px;
    }

    .cell {
        width: 70px;
        height: 70px;
        background: var(--cell-bg);
        border-radius: 16px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 28px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        box-shadow: 
            0 4px 6px rgba(0,0,0,0.05),
            0 1px 3px rgba(0,0,0,0.1);
        border: 2px solid transparent;
        color: #2c3e50;
    }

    .cell:hover {
        transform: translateY(-2px);
        box-shadow: 
            0 6px 8px rgba(0,0,0,0.1),
            0 2px 4px rgba(0,0,0,0.06);
    }

    .cell.active {
        background: linear-gradient(135deg, #90caf9, #64b5f6);
        color: white;
        border-color: #64b5f6;
    }

    .cell.hint {
        background: linear-gradient(135deg, #90caf9, #64b5f6);
        color: white;
        border-color: #64b5f6;
    }

    .cell.error {
        background: linear-gradient(135deg, #ef5350, #e53935);
        color: white;
        border-color: #e53935;
    }

    .cell.correct {
        background: linear-gradient(135deg, #81c784, #66bb6a);
        color: white;
        border-color: #66bb6a;
    }

    .level-display {
        font-size: 24px;
        font-weight: 600;
        text-align: center;
        margin-bottom: 20px;
        color: #2c3e50;
        text-transform: uppercase;
        letter-spacing: 1px;
    }

    .path-line {
        position: absolute;
        background: linear-gradient(90deg, var(--primary), var(--primary-dark));
        height: 6px;
        border-radius: 3px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        opacity: 0.8;
    }

    button {
        background: linear-gradient(45deg, var(--primary), var(--primary-dark));
        color: white;
        border: none;
        border-radius: 12px;
        padding: 12px 30px;
        font-size: 18px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        text-transform: uppercase;
        letter-spacing: 1px;
        display: block;
        margin: 0 auto;
    }

    button:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 8px rgba(0,0,0,0.15);
        background: linear-gradient(45deg, #357abd, #2c6ba9);
    }

    button:active {
        transform: translateY(0);
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .lines-container {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
    }

    /* SEO Section Styles */
    section {
        max-width: 800px;
        margin: 60px auto;
        padding: 30px;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 24px;
        box-shadow: 
            0 4px 6px rgba(0,0,0,0.05),
            0 1px 3px rgba(0,0,0,0.1);
    }

    article {
        margin-bottom: 40px;
    }

    h2 {
        color: #2c3e50;
        font-size: 24px;
        font-weight: 700;
        margin-bottom: 20px;
        position: relative;
        padding-bottom: 10px;
    }

    h2::after {
        content: '';
        position: absolute;
        bottom: 0;
        left: 0;
        width: 60px;
        height: 4px;
        background: linear-gradient(45deg, var(--primary), var(--primary-dark));
        border-radius: 2px;
    }

    ul {
        list-style-type: none;
        padding: 0;
    }

    ul li {
        padding: 10px 0;
        padding-left: 25px;
        position: relative;
    }

    ul li::before {
        content: '';
        position: absolute;
        left: 0;
        top: 50%;
        width: 8px;
        height: 8px;
        background: var(--primary);
        border-radius: 50%;
        transform: translateY(-50%);
    }

    @media (max-width: 768px) {
        .game-title {
            font-size: 36px;
        }
        
        .cell {
            width: 60px;
            height: 60px;
            font-size: 24px;
        }
        
        .game-container {
            padding: 20px;
        }
        
        section {
            padding: 20px;
            margin: 40px auto;
        }
    }
    
    .game-container {
        background: white;
        padding: 20px;
        border-radius: 12px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        margin-bottom: 20px;
        position: relative;
    }
    .game-grid {
        display: grid;
        gap: 10px;
        touch-action: none;
        user-select: none;
        position: relative;
        margin: 20px 0;
    }
    .cell {
        width: 60px;
        height: 60px;
        background: #e0e0e0;
        border-radius: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 24px;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.3s ease;
    }
    .cell.active {
        background: #b3e0ff;
    }
    .cell.hint {
        background: #b3e0ff;
    }
    .cell.error {
        background: #ffb3b3;
    }
    .cell.correct {
        background: #b3ffb3;
    }
    .lines-container {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 1;
    }
    .path-line {
        position: absolute;
        background: #4a90e2;
        height: 4px;
        transform-origin: left center;
        pointer-events: none;
    }
    button {
        padding: 10px 20px;
        font-size: 16px;
        background: #4a90e2;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
    }
    button:hover {
        background: #357abd;
    }
    h1 {
        margin-bottom: 20px;
    }
    .level-display {
        font-size: 18px;
        margin-bottom: 10px;
        text-align: center;
    }
    footer {
        text-align: center;
        padding: 20px;
        background-color: #333;
        color: white;
        border-radius: 10px;
        margin-top: 20px;
    }

    footer a {
        color: #4CAF50;
        text-decoration: none;
    }

    footer a:hover {
        text-decoration: underline;
    }

    @media (max-width: 600px) {
        body {
            padding: 10px;
        }
        
        .game-container {
            padding: 15px;
        }
        
        .cell {
            width: 50px;
            height: 50px;
            font-size: 20px;
        }
    }
    </style>
</head>
<body>
    <header>
        <a href="../" style="text-decoration: none; color: inherit;">
        <h1>Orber</h1>
    </a>
        <p>Connect numbers in sequence to solve the puzzle!</p>
    </header>

    <h1 class="game-title">Orber</h1>
    <p class="game-intro">
        Derived from "Order" and "Number", Orber is a puzzle game where you create paths by connecting numbers in sequence. Follow the hints and find your way through increasingly challenging levels. Each move matters as you can only connect adjacent squares.
    </p>
    <div class="level-display">
        Level: <span id="currentLevel">1</span>
    </div>
    <div id="gameContainer" class="game-container">
        <div id="gameGrid" class="game-grid"></div>
        <div id="linesContainer" class="lines-container"></div>
    </div>
    <!--<button id="resetBtn">Reset Level</button>-->
    <section class="mt-8 p-4 max-w-2xl mx-auto text-gray-700">
        <article class="mb-8">
            <h2 class="text-xl font-bold mb-4">What is Orber?</h2>
            <p class="mb-4">
                Orber is an innovative puzzle game that combines numerical sequences with pathfinding. The name "Orber" cleverly merges "Order" and "Number", reflecting the game's core mechanics where players must create ordered paths through a grid of numbers.
            </p>
            <p class="mb-4">
                Perfect for puzzle enthusiasts and anyone looking to challenge their logical thinking, Orber offers a unique gaming experience that starts simple but gradually increases in complexity as you progress through its carefully designed levels.
            </p>
        </article>

        <article class="mb-8">
            <h2 class="text-xl font-bold mb-4">How to Play</h2>
            <ul class="list-disc pl-5 mb-4">
                <li class="mb-2">Start with a grid containing hint numbers</li>
                <li class="mb-2">Connect adjacent squares in numerical order</li>
                <li class="mb-2">Each number must be connected to its neighbors (no diagonal moves)</li>
                <li class="mb-2">Complete the path by connecting all squares in the correct sequence</li>
                <li class="mb-2">Use hint numbers as guides to solve each puzzle</li>
            </ul>
        </article>

        <article class="mb-8">
            <h2 class="text-xl font-bold mb-4">Key Features</h2>
            <ul class="list-disc pl-5">
                <li class="mb-2">Progressive difficulty across multiple levels</li>
                <li class="mb-2">Intuitive touch and mouse controls</li>
                <li class="mb-2">Visual feedback with color-coded paths</li>
                <li class="mb-2">Audio cues for moves and completions</li>
                <li class="mb-2">Brain-teasing puzzles suitable for all ages</li>
            </ul>
        </article>

        <article>
            <h2 class="text-xl font-bold mb-4">Why Play Orber?</h2>
            <p class="mb-4">
                Orber stands out in the puzzle game genre by combining simple rules with deep strategic gameplay. Each level presents a unique challenge that exercises your spatial reasoning and planning abilities. Whether you're a casual player or a puzzle game enthusiast, Orber offers an engaging experience that's easy to learn but satisfying to master.
            </p>
            <p class="mb-4">
                The game's minimalist design focuses your attention on solving puzzles while providing clear visual feedback. With its gradual progression in difficulty, Orber keeps you engaged as you develop your problem-solving skills through increasingly complex challenges.
            </p>
        </article>
    </section>

    <script>
        class SoundEffect {
            constructor() {
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }

            playClick() {
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(800, this.audioContext.currentTime);
                
                gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.1);
                
                oscillator.start();
                oscillator.stop(this.audioContext.currentTime + 0.1);
            }

            playError() {
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(300, this.audioContext.currentTime);
                oscillator.frequency.setValueAtTime(200, this.audioContext.currentTime + 0.1);
                
                gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.01, this.audioContext.currentTime + 0.2);
                
                oscillator.start();
                oscillator.stop(this.audioContext.currentTime + 0.2);
            }

            playComplete() {
                const notes = [400, 500, 600, 800];
                notes.forEach((freq, index) => {
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(freq, this.audioContext.currentTime + index * 0.1);
                    
                    gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime + index * 0.1);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + index * 0.1 + 0.1);
                    
                    oscillator.start(this.audioContext.currentTime + index * 0.1);
                    oscillator.stop(this.audioContext.currentTime + index * 0.1 + 0.1);
                });
            }
        }


        class Game {
            constructor() {
                this.currentLevel = 1;
                this.gridSize = 2;
                this.cells = [];
                this.solution = [];
                this.hints = new Set();
                this.path = [];
                this.isDragging = false;
                this.lastCell = null;
                
                this.gameContainer = document.getElementById('gameContainer');
                this.gameGrid = document.getElementById('gameGrid');
                this.linesContainer = document.getElementById('linesContainer');
                //this.resetBtn = document.getElementById('resetBtn');
                this.levelDisplay = document.getElementById('currentLevel');

                this.sound = new SoundEffect();
                
                this.init();
            }

            init() {
                // ÁªëÂÆö‰∫ã‰ª∂Â§ÑÁêÜÂô®Âà∞ÂÆû‰æã
                this.handleStart = this.handleStart.bind(this);
                this.handleMove = this.handleMove.bind(this);
                this.handleEnd = this.handleEnd.bind(this);
                this.setupEventListeners();
                this.initLevel();
            }

            setupEventListeners() {
                //this.resetBtn.addEventListener('click', () => this.initLevel());
                
                this.gameGrid.addEventListener('mousedown', this.handleStart);
                document.addEventListener('mousemove', this.handleMove);
                document.addEventListener('mouseup', this.handleEnd);
                
                this.gameGrid.addEventListener('touchstart', this.handleStart);
                document.addEventListener('touchmove', this.handleMove);
                document.addEventListener('touchend', this.handleEnd);
            }

            isAdjacent(index1, index2) {
                const row1 = Math.floor(index1 / this.gridSize);
                const col1 = index1 % this.gridSize;
                const row2 = Math.floor(index2 / this.gridSize);
                const col2 = index2 % this.gridSize;
                return Math.abs(row1 - row2) + Math.abs(col1 - col2) === 1;
            }

            generateValidPath() {
                const totalCells = this.gridSize * this.gridSize;
                let attempts = 0;
                let validPath = null;

                while (!validPath && attempts < 100) {
                    attempts++;
                    let path = [Math.floor(Math.random() * totalCells)];
                    let available = new Set();

                    for (let i = 0; i < totalCells; i++) {
                        if (i !== path[0]) available.add(i);
                    }

                    while (path.length < totalCells && available.size > 0) {
                        const lastCell = path[path.length - 1];
                        const validMoves = [...available].filter(next => this.isAdjacent(lastCell, next));

                        if (validMoves.length === 0) break;

                        const nextCell = validMoves[Math.floor(Math.random() * validMoves.length)];
                        path.push(nextCell);
                        available.delete(nextCell);
                    }

                    if (path.length === totalCells) {
                        validPath = path;
                    }
                }

                return validPath;
            }

            initLevel() {
                this.gridSize = this.currentLevel <= 2 ? 2 : 
                               this.currentLevel <= 6 ? 3 : 4;

                // ÁîüÊàêÊúâÊïàË∑ØÂæÑ
                this.solution = this.generateValidPath();
                if (!this.solution) {
                    console.error("Could not generate valid path");
                    return;
                }

                // ÈÄâÊã©ÊèêÁ§∫Êï∞Â≠óÔºàÊéíÈô§1Ôºâ
                const totalCells = this.gridSize * this.gridSize;
                const hintCount = Math.min(
                    Math.floor(totalCells / 2),
                    this.currentLevel <= 2 ? 1 : 
                    this.currentLevel <= 6 ? Math.floor((this.currentLevel - 2) / 2) + 1 : 4
                );

                this.hints.clear();
                while (this.hints.size < hintCount) {
                    const position = Math.floor(Math.random() * (totalCells - 1)) + 2; // ÊéíÈô§1
                    this.hints.add(position);
                }

                // ÈáçÁΩÆÁä∂ÊÄÅ
                this.path = [];
                this.lastCell = null;
                this.linesContainer.innerHTML = '';
                
                this.createGrid();
            }

            createGrid() {
                this.gameGrid.innerHTML = '';
                this.cells = [];
                
                this.gameGrid.style.gridTemplateColumns = `repeat(${this.gridSize}, 60px)`;

                for (let i = 0; i < this.gridSize * this.gridSize; i++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.index = i;
                    
                    const solutionIndex = this.solution.indexOf(i);
                    if (this.hints.has(solutionIndex + 1)) {
                        cell.textContent = (solutionIndex + 1).toString();
                        cell.classList.add('active');
                    }
                    
                    this.gameGrid.appendChild(cell);
                    this.cells.push(cell);
                }
            }

            handleStart(e) {
                e.preventDefault();
                const cell = this.getCellFromEvent(e);
                if (!cell) return;

                this.isDragging = true;
                this.path = [];
                this.linesContainer.innerHTML = '';
                this.addToPath(cell);
            }

            handleMove(e) {
                if (!this.isDragging) return;
                e.preventDefault();
                
                const cell = this.getCellFromEvent(e);
                if (!cell || cell === this.lastCell) return;

                if (this.isValidNextCell(cell)) {
                    this.addToPath(cell);
                }
            }

            handleEnd() {
                this.isDragging = false;
                
                if (this.isLevelComplete()) {
                    this.sound.playComplete(); // ÂÆåÊàêÈü≥Êïà
                    setTimeout(() => {
                        this.currentLevel++;
                        this.levelDisplay.textContent = this.currentLevel;
                        this.initLevel();
                    }, 500); // Âª∂ÈïøÁ≠âÂæÖÊó∂Èó¥ÔºåËÆ©ÂÆåÊàêÈü≥ÊïàÊí≠ÊîæÂÆå
                }
            }

            getCellFromEvent(e) {
                const point = e.touches ? e.touches[0] : e;
                const element = document.elementFromPoint(point.clientX, point.clientY);
                if (element && element.classList.contains('cell')) {
                    return element;
                }
                return null;
            }

            isValidNextCell(cell) {
                if (!this.lastCell) return true;
                
                const lastIndex = parseInt(this.lastCell.dataset.index);
                const currentIndex = parseInt(cell.dataset.index);
                
                return this.isAdjacent(lastIndex, currentIndex);
            }

            addToPath(cell) {
                const index = parseInt(cell.dataset.index);
                if (!this.path.includes(index)) {
                    this.path.push(index);
                    this.lastCell = cell;
                    
                    const solutionIndex = this.solution.indexOf(index);
                    const pathIndex = this.path.length - 1;
                    
                    // Êí≠ÊîæÁõ∏Â∫îÁöÑÈü≥Êïà
                    if (this.hints.has(solutionIndex + 1)) {
                        if (pathIndex === solutionIndex) {
                            this.sound.playClick(); // Ê≠£Á°Æ‰ΩçÁΩÆ
                        } else {
                            this.sound.playError(); // ÈîôËØØ‰ΩçÁΩÆ
                        }
                    } else {
                        this.sound.playClick(); // ÊôÆÈÄöÁßªÂä®
                    }
                    
                    this.updateUI();
                    this.drawPaths();
                }
            }

            updateUI() {
                const isComplete = this.isLevelComplete();
                
                this.cells.forEach((cell, index) => {
                    const pathIndex = this.path.indexOf(index); // Áî®Êà∑Ë∑ØÂæÑ‰∏≠ÁöÑ‰ΩçÁΩÆ
                    const solutionIndex = this.solution.indexOf(index); // Ëß£ÂÜ≥ÊñπÊ°à‰∏≠ÁöÑ‰ΩçÁΩÆ
                    
                    // ÈáçÁΩÆÊâÄÊúâÁ±ª
                    cell.classList.remove('active', 'hint', 'error', 'correct');
                    
                    if (this.hints.has(solutionIndex + 1)) {
                        // ËøôÊòØ‰∏Ä‰∏™È¢ÑËÆæÊï∞Â≠óÁöÑÊ†ºÂ≠ê
                        cell.textContent = (solutionIndex + 1).toString();
                        
                        if (pathIndex !== -1) {
                            // Áî®Êà∑Â∑≤ÁªèËøûÂà∞Ëøô‰∏™Ê†ºÂ≠ê
                            if (pathIndex === solutionIndex) {
                                // ‰ΩçÁΩÆÊ≠£Á°Æ
                                cell.classList.add(isComplete ? 'correct' : 'hint');
                            } else {
                                // ‰ΩçÁΩÆÈîôËØØ
                                cell.classList.add('error');
                            }
                        } else {
                            // ËøòÊú™ËøûÂà∞Ëøô‰∏™Ê†ºÂ≠ê
                            cell.classList.add('hint');
                        }
                    } else {
                        // ÈùûÈ¢ÑËÆæÊï∞Â≠óÁöÑÊ†ºÂ≠ê
                        if (pathIndex !== -1) {
                            // Áî®Êà∑Â∑≤ËøûÂà∞ÁöÑÊ†ºÂ≠ê
                            cell.textContent = (pathIndex + 1).toString();
                            cell.classList.add(isComplete ? 'correct' : 'active');
                        } else {
                            // Êú™ËøûÂà∞ÁöÑÊ†ºÂ≠ê
                            cell.textContent = '';
                        }
                    }
                });
            }

            drawPaths() {
                if (!this.gameContainer) return;
                
                this.linesContainer.innerHTML = '';
                const containerRect = this.gameContainer.getBoundingClientRect();

                for (let i = 0; i < this.path.length - 1; i++) {
                    const startCell = this.cells[this.path[i]];
                    const endCell = this.cells[this.path[i + 1]];
                    
                    if (!startCell || !endCell) continue;
                    
                    const start = startCell.getBoundingClientRect();
                    const end = endCell.getBoundingClientRect();
                    
                    const line = document.createElement('div');
                    line.className = 'path-line';
                    
                    const dx = end.left - start.left;
                    const dy = end.top - start.top;
                    const length = Math.sqrt(dx * dx + dy * dy);
                    const angle = Math.atan2(dy, dx);
                    
                    line.style.width = `${length}px`;
                    line.style.left = `${start.left - containerRect.left + start.width/2}px`;
                    line.style.top = `${start.top - containerRect.top + start.height/2}px`;
                    line.style.transform = `rotate(${angle}rad)`;
                    
                    this.linesContainer.appendChild(line);
                }
            }

            isLevelComplete() {
                // Ê£ÄÊü•ÊòØÂê¶ÊâÄÊúâÊ†ºÂ≠êÈÉΩËøû‰∏ä‰∫Ü
                if (this.path.length !== this.gridSize * this.gridSize) return false;
                
                // Ê£ÄÊü•ÊèêÁ§∫Êï∞Â≠óÊòØÂê¶Âú®Ê≠£Á°ÆÁöÑ‰ΩçÁΩÆ
                for (const hintNumber of this.hints) {
                    const requiredCellIndex = this.solution[hintNumber - 1];
                    const playerPathIndex = this.path.indexOf(requiredCellIndex);
                    if (playerPathIndex !== hintNumber - 1) {
                        return false;
                    }
                }
                
                return true;
            }


            isLevelComplete1() {
                // Ê£ÄÊü•ÊòØÂê¶ÊâÄÊúâÊ†ºÂ≠êÈÉΩËøû‰∏ä‰∫Ü
                if (this.path.length !== this.gridSize * this.gridSize) return false;
                
                // Ê£ÄÊü•ÊèêÁ§∫Êï∞Â≠óÊòØÂê¶Âú®Ê≠£Á°ÆÁöÑ‰ΩçÁΩÆ
                for (const hintNumber of this.hints) {
                    // hintNumber ÊòØËøô‰∏™Ê†ºÂ≠êÂ∫îËØ•Âú®Ë∑ØÂæÑ‰∏≠ÁöÑ‰ΩçÁΩÆÔºàÁ¨¨Âá†Ê≠•Ôºâ
                    // ÈúÄË¶ÅÊâæÂà∞Âú®solution‰∏≠ÂØπÂ∫îËøô‰∏™Êï∞Â≠óÁöÑÊ†ºÂ≠êÁ¥¢Âºï
                    const requiredCellIndex = this.solution[hintNumber - 1];
                    // Ê£ÄÊü•Ëøô‰∏™Ê†ºÂ≠êÊòØÂê¶Âú®Áé©ÂÆ∂Ë∑ØÂæÑÁöÑÊ≠£Á°Æ‰ΩçÁΩÆ
                    const playerPathIndex = this.path.indexOf(requiredCellIndex);
                    if (playerPathIndex !== hintNumber - 1) {
                        return false;
                    }
                }
                
                // ÊâÄÊúâÊ£ÄÊü•ÈÉΩÈÄöËøá
                return true;
            }
        }

        // Start the game
        window.onload = () => new Game();
    </script>
    <script defer data-domain="memorytest.io" src="https://click.pageview.click/js/script.js"></script>
    <footer style="display: flex; flex-direction: column; align-items: center; padding: 20px; background-color: #f0f0f0; font-family: Arial, sans-serif;">
        <div style="display: flex; justify-content: center; gap: 20px; margin-bottom: 15px;">
            <a href="https://snakeapplega.me/privacy.html" style="text-decoration: none; color: #333;">Privacy Policy</a>
            <a href="https://snakeapplega.me/blog/" style="text-decoration: none; color: #333;">Blog</a>
            <a href="https://snakeapplega.me/copyright.html" style="text-decoration: none; color: #333;">Copyright Notice</a>
        </div>
        <select onchange="window.location.href=this.value;" style="margin-bottom: 15px; padding: 5px; border-radius: 5px;">
            <option value=""> Select Language</option>
            <option value="index.html">English</option>
            <option value="/hi/index.html">‡§π‡§ø‡§Ç‡§¶‡•Ä</option>
            <option value="/tl/index.html">Filipino</option>
            <option value="/fr/index.html">Fran√ßais</option>
            <option value="/ja/index.html">Êó•Êú¨Ë™û</option>
            <option value="/ar/index.html">ÿπÿ±ÿ®Ÿä</option>
            <option value="/ml/index.html">Melayu</option>
        </select>
        <p style="margin: 0; text-align: center;">&copy; 2024 SnakeAppleGa.me. All rights reserved. üêçüçé</p>
    </footer>
    <script src="../game-date.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            renderGames('games-container');
        });
    </script>
    <div style="display:none;">
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-JG3HGMNS6B"></script>
    <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-JG3HGMNS6B');
     </script>
    </div>
</body>
</html>
